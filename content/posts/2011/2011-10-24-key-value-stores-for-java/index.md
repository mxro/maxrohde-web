---
authors:
- max
blog: maxrohde.com
categories:
- java
date: "2011-10-24"
title: Key-Value Stores for Java
---

One common theme in discussions of persistence is to be critical of the traditional SQL databases, which have been successfully used in business applications for decades. As alternative to these SQL databases, often so called NoSQL solutions are advocated. NoSQL, essentially, dramatically simplifies the kind of data, which can be managed by the database. Often, a simple key-value store is at the heart of the database. Such stores allow the user to store data in a similar way as it has long been known for the [Map](http://download.oracle.com/javase/6/docs/api/java/util/Map.html) data structure. However, whereas the traditionally Maps have been used in-memory, e.g. to hold data temporarily, which fits on one system's memory, NoSQL key value stores are designed to persist and scale up to millions or billions of key-value records, distributed among potentially thousands of servers. As can be expected, in the Java space, there is not one all-encompassing NoSQL solution but various (mostly free and open source) offerings compete with varying features.

In the following I discuss two categories of implementations:

1. Object Prevalence engines: which assure objects stored in memory are never lost and constantly backed up onto a hard disk.
2. Persisted Databases engines: which allow to work with key-value databases, which are larger than the systems memory by persisting parts of them onto a hard disk (or another persistence backend).

### Object Prevalence

Object Prevalence systems keep all records in-memory. However, they are designed to keep a synchronized persisted copy of all objects on the hard disk. In case of a system failure or reboot they therewith can easily restore the state before the interruption. Object prevalence systems are often used to speed up applications, for which all required data can be stored in memory ([Villela, 1st of August 2002](http://www.ibm.com/developerworks/library/wa-objprev/)).

One prominent example of an object prevalence system is the open source solution Prevayler ([http://prevayler.org](http://prevayler.org)). A significant limitation for such object prevalence systems is, of course, that the amount of data the application can work with is limited to the memory available on one server. To allow systems to scale, an object prevalence system can be distributed among various systems. A very well-performing open source solution for this purpose is hazelcast ([http://www.hazelcast.com/](http://www.hazelcast.com/)).

<table style="border-collapse:collapse;" border="0"><tbody><tr><td style="padding-left:7px;padding-right:7px;border:solid .5pt;"><strong>Engine</strong></td><td style="padding-left:7px;padding-right:7px;border-top:solid .5pt;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><strong>Project home</strong></td><td style="padding-left:7px;padding-right:7px;border-top:solid .5pt;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><strong>Description</strong></td></tr><tr><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:solid .5pt;border-bottom:solid .5pt;border-right:solid .5pt;">Prevayler</td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><a href="http://prevayler.org">http://prevayler.org</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;">Lightweight solution to build prevalent systems.</td></tr><tr><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:solid .5pt;border-bottom:solid .5pt;border-right:solid .5pt;">Space4j</td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><a href="http://www.space4j.org/">http://www.space4j.org/</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;">Keeps an incremental record of all operations saved on disk in order to recreate a state in memory (but also has the option to create snapshots).</td></tr><tr><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:solid .5pt;border-bottom:solid .5pt;border-right:solid .5pt;">MegaMap</td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><a href="http://megamap.sourceforge.net/">http://megamap.sourceforge.net/</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;">Allows to work with Maps larger than the memory and persist these onto disk. However, not developed for a while and not fault tolerant.</td></tr><tr><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:solid .5pt;border-bottom:solid .5pt;border-right:solid .5pt;">hazelcast</td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><a href="http://www.hazelcast.com/">http://www.hazelcast.com/</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;">Allows to distribute objects held in memory among a cluster of physical systems (within a network or connected through WAN).</td></tr></tbody></table>

### Persisted Databases

While object prevalence systems are arguably one of the best performing solutions to store the data of an application, there are many use cases, in which data is only rarely accessed and therewith not required to be available in memory. For these purposes key-value stores, which keep only a fraction of their data in the memory are best suited. Below a number of examples implementing this pattern. To get started quickly, I think jdbm2 is a good option, for large scale solutions, you might have to consider Berkely DB – but this might end up being a pricy pathway.

<table style="border-collapse:collapse;" border="0"><tbody><tr><td style="padding-left:7px;padding-right:7px;border:solid .5pt;"><strong>Engine</strong></td><td style="padding-left:7px;padding-right:7px;border-top:solid .5pt;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><strong>Project home</strong></td><td style="padding-left:7px;padding-right:7px;border-top:solid .5pt;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><strong>Description</strong></td></tr><tr><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:solid .5pt;border-bottom:solid .5pt;border-right:solid .5pt;">jdbm2</td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><a href="http://code.google.com/p/jdbm2/">http://code.google.com/p/jdbm2/</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;">Persists a HashMap or TreeMap using Java Serialization.</td></tr><tr><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:solid .5pt;border-bottom:solid .5pt;border-right:solid .5pt;">mapdb</td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><a href="https://github.com/jankotek/mapdb">https://github.com/jankotek/mapdb</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;">Evolution of JDBM 2 (was initially known as JDBM 4)</td></tr><tr><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:solid .5pt;border-bottom:solid .5pt;border-right:solid .5pt;">Banana DB</td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><a href="http://people.apache.org/~kalle/bananadb/">http://people.apache.org/~kalle/bananadb/</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;">Persists a Map in a file. Potentially inefficient read operations.</td></tr><tr><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:solid .5pt;border-bottom:solid .5pt;border-right:solid .5pt;"><a title="Performance Tests of Babu DB" href="http://maxrohde.com/2011/11/30/key-value-store-for-java-babu-db/">BabuDB</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><a href="http://code.google.com/p/babudb/">http://code.google.com/p/babudb/</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;">Persists key-value pairs of byte[] values.</td></tr><tr><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:solid .5pt;border-bottom:solid .5pt;border-right:solid .5pt;">Berkeley DB</td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><a href="http://www.oracle.com/technetwork/%20database/berkeleydb">http://www.oracle.com/technetwork/ database/berkeleydb</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;">Key-value store solution from Oracle. Rather restrictive open-source licence.</td></tr><tr><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:solid .5pt;border-bottom:solid .5pt;border-right:solid .5pt;">JOAFIP</td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;"><a href="http://joafip.sourceforge.net/">http://joafip.sourceforge.net/</a></td><td style="padding-left:7px;padding-right:7px;border-top:none;border-left:none;border-bottom:solid .5pt;border-right:solid .5pt;">Rather than providing a simple key-value store, JOAFIP attempts to dynamically persist an object tree to the disk (to manage object trees too large to fit into memory).</td></tr></tbody></table>

### Resources

#### JDBM

"[HIVE-1754 - Remove JDBM component from Map Join](https://issues.apache.org/jira/browse/HIVE-1754)" Apache Hadoop has removed the JDBM dependency from their codebase due to poor performance. However, they seem to have replaced the persistence backed map with a map solely in memory. So they did not really find a better alternative for JDBM but rather removed the necessity for file-based persistence altogether. The old implementation of JDBM used by them can be found in the source repositories: e.g. [BaseRecordManager in hive-0.5.0](http://www.docjar.com/html/api/org/apache/hadoop/hive/ql/util/jdbm/recman/BaseRecordManager.java.html), or how it was used in [HashMapWrappper also in hive-0.5.0](http://massapi.com/source/hive-0.5.0-dev/src/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/HashMapWrapper.java.html).

"[JDBM2 released](http://kotek.net/blog/jdbm2_released)" Blog post with some additional info concerning JDBM2

#### SQL Alternatives

For an SQL database with a very low footprint and high performance see: [http://www.h2database.com/](http://www.h2database.com/)

#### Other Resources

"An introduction to object prevalence" ([Villela, 1st of August 2002](http://www.ibm.com/developerworks/library/wa-objprev/))

"Anti-RDBMS: A list of distributed key-value stores" ([Jones, 19th of January 2009](http://www.metabrew.com/article/anti-rdbms-a-list-of-distributed-key-value-stores))

"NoSQL Services Available" ([Menon, 29th of March 2011](http://www.menon.bz/sblog/?p=721))

"The Jalapeño Persistence Library for Java" ([intersystems.com](http://docs.intersystems.com/cache20111/csp/docbook/DocBook.UI.Page.cls?KEY=GBJJ_intro))

"POJO Persistence" ([on this blog](http://maxrohde.com/2010/10/12/pojo-persistence/))

Prevayler ([http://prevayler.org](http://prevayler.org))

hazelcast ([http://www.hazelcast.com/](http://www.hazelcast.com/))
